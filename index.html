<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ç”Ÿæ—¥å¿«ä¹ï¼šæ¢¦å¢ƒæ‰‹åŠ¿é­”æ³•ç³»ç»Ÿ</title>
    <style>
        :root { --pink: #FF69B4; --gold: #FFD700; --violet: #4B0082; --white: #FFFFFF; }
        body { margin: 0; overflow: hidden; background: #010105; font-family: "PingFang SC", "Microsoft YaHei", sans-serif; }

        /* UI å åŠ å±‚ */
        #ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            padding: 50px; box-sizing: border-box;
        }

        .text-group { text-align: center; }
        .main-title {
            font-size: 60px; font-weight: 900; letter-spacing: 15px;
            background: linear-gradient(to bottom, #fff, var(--pink), var(--violet));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(255,105,180,0.5));
            margin-bottom: 5px;
        }
        .quote { color: rgba(255,255,255,0.6); font-size: 16px; letter-spacing: 4px; font-family: "æ¥·ä½“", serif; }

        /* å¼•å¯¼ä¸ç¼©æ”¾æç¤º */
        #hint-box {
            background: rgba(0,0,0,0.6); backdrop-filter: blur(15px);
            border: 1px solid rgba(255,105,180,0.4); padding: 20px 50px;
            border-radius: 60px; color: var(--white); text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #step-hint { font-size: 26px; color: var(--gold); font-weight: bold; margin-bottom: 5px; }
        #control-hint { font-size: 14px; color: var(--pink); letter-spacing: 2px; }

        /* ä¾§è¾¹è¿›åº¦ */
        #nav { position: absolute; left: 30px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; gap: 15px; }
        .dot { width: 10px; height: 10px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.3); transition: 0.5s; }
        .dot.active { background: var(--gold); transform: scale(1.8); box-shadow: 0 0 15px var(--gold); }

        #cam-preview {
            position: absolute; bottom: 30px; right: 30px;
            width: 160px; height: 120px; border-radius: 15px;
            overflow: hidden; border: 2px solid var(--pink);
            transform: scaleX(-1); opacity: 0.6; z-index: 50;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <div class="text-group">
            <div class="main-title">ç”Ÿæ—¥å¿«ä¹</div>
            <div class="quote">â€œç¥ å·¥ä½œé¡ºåˆ©ã€æ—¥å­å¸¸æš–ã€å²å²æœ‰å®‰ï¼â€</div>
        </div>

        <div id="hint-box">
            <div id="step-hint">æ­£åœ¨å”¤é†’é­”æ³•...</div>
            <div id="control-hint">âœ¨ å¼ åˆæ‰‹æŒ‡æ§åˆ¶ç²’å­æ”¶æ”¾</div>
        </div>
    </div>

    <div id="nav">
        <div class="dot" id="d0"></div>
        <div class="dot" id="d1"></div>
        <div class="dot" id="d2"></div>
        <div class="dot" id="d3"></div>
        <div class="dot" id="d4"></div>
    </div>

    <div id="cam-preview"><video id="webcam" autoplay playsinline></video></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, composer, clock;
        let particles, geometry, stars, fwGeo, fwPoints;
        const COUNT = 30000;
        const FW_COUNT = 3000;

        let state = 0; 
        let isTransitioning = false;
        let scaleRef = 1.0;
        let rotationY = 0;

        const targetPos = new Float32Array(COUNT * 3);
        const targetCol = new Float32Array(COUNT * 3);
        const currentPos = new Float32Array(COUNT * 3);

        const COLORS = {
            pink: new THREE.Color(0xFF69B4),
            white: new THREE.Color(0xFFFFFF),
            gold: new THREE.Color(0xFFD700),
            violet: new THREE.Color(0x310062)
        };

        // --- åˆå§‹åŒ– ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloom.threshold = 0.1; bloom.strength = 1.5;
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);

            createStarField();
            createMainParticles();
            createFireworkSystem();
            setupMediaPipe();
            setShape(0);

            window.addEventListener('resize', onResize);
            clock = new THREE.Clock();
            animate();
        }

        function createStarField() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(3000 * 3);
            for(let i=0; i<3000; i++) {
                pos[i*3] = (Math.random()-0.5)*80;
                pos[i*3+1] = (Math.random()-0.5)*80;
                pos[i*3+2] = (Math.random()-0.5)*40 - 20;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            stars = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.02, color: 0xffffff, transparent: true, opacity: 0.8 }));
            scene.add(stars);
        }

        function createMainParticles() {
            geometry = new THREE.BufferGeometry();
            const cols = new Float32Array(COUNT * 3);
            for(let i=0; i<COUNT; i++) {
                currentPos[i*3] = (Math.random()-0.5)*20;
                currentPos[i*3+1] = (Math.random()-0.5)*20;
                currentPos[i*3+2] = (Math.random()-0.5)*10;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(currentPos, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(cols, 3));
            const mat = new THREE.PointsMaterial({
                size: 0.04, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending,
                map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/ball.png')
            });
            particles = new THREE.Points(geometry, mat);
            scene.add(particles);
        }

        function createFireworkSystem() {
            fwGeo = new THREE.BufferGeometry();
            const pos = new Float32Array(FW_COUNT * 3);
            const cols = new Float32Array(FW_COUNT * 3);
            for(let i=0; i<FW_COUNT; i++) pos[i*3] = 9999;
            fwGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            fwGeo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
            fwPoints = new THREE.Points(fwGeo, new THREE.PointsMaterial({ size: 0.03, vertexColors: true, blending: THREE.AdditiveBlending }));
            scene.add(fwPoints);
        }

        // --- æ ¸å¿ƒå½¢çŠ¶ï¼šå½»åº•é‡å†™æ•°å­—â€œ2â€ ---

        function setShape(s) {
            if (isTransitioning) return;
            isTransitioning = true;
            state = s;
            
            if (s === 0) fillGarden();
            else if (s === 1) fillNumberOne();
            else if (s === 2) fillNumberTwo();
            else if (s === 3) fillNumberThree();
            else fillCake();

            document.querySelectorAll('.dot').forEach((d, i) => d.classList.toggle('active', i === s));
            setTimeout(() => { isTransitioning = false; }, 1000);
        }

        function applyToTarget(points, color, thickness) {
            for(let i=0; i<COUNT; i++) {
                const i3 = i*3;
                const base = points[i % points.length];
                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()) * thickness;
                targetPos[i3] = base.x + Math.cos(angle) * r;
                targetPos[i3+1] = base.y + Math.sin(angle) * r;
                targetPos[i3+2] = (Math.random() - 0.5) * thickness;
                targetCol[i3] = color.r; targetCol[i3+1] = color.g; targetCol[i3+2] = color.b;
            }
        }

        function fillGarden() {
            for(let i=0; i<COUNT; i++) {
                const i3 = i*3;
                targetPos[i3] = (Math.random()-0.5)*15;
                targetPos[i3+1] = (Math.random()-0.5)*12;
                targetPos[i3+2] = (Math.random()-0.5)*8;
                const c = i%2===0 ? COLORS.violet : COLORS.gold;
                targetCol[i3]=c.r; targetCol[i3+1]=c.g; targetCol[i3+2]=c.b;
            }
        }

        function fillNumberOne() {
            const pts = [];
            for(let y=-2.5; y<2.5; y+=0.05) pts.push(new THREE.Vector3(0, y, 0)); // ä¸»å¹²
            for(let i=0; i<40; i++) pts.push(new THREE.Vector3(-i*0.03, 2.5-i*0.03, 0)); // å‹¾
            for(let x=-0.8; x<0.8; x+=0.05) pts.push(new THREE.Vector3(x, -2.5, 0)); // åº•
            applyToTarget(pts, COLORS.gold, 0.5);
        }

        function fillNumberTwo() {
            // ä½¿ç”¨é”šç‚¹æ³•å®šä¹‰å®Œç¾çš„æ•°å­— 2
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-0.8, 0.8, 0),  // èµ·ç‚¹ï¼šå†…å‹¾
                new THREE.Vector3(-0.4, 1.8, 0),  // é¡¶éƒ¨åœ†å¼§å·¦
                new THREE.Vector3(0.8, 1.8, 0),   // é¡¶éƒ¨åœ†å¼§å³
                new THREE.Vector3(0.8, 0.6, 0),   // è„–å­è½¬æŠ˜
                new THREE.Vector3(-0.8, -1.8, 0), // æ–œæ¢ç»ˆç‚¹ï¼ˆåº•åº§å·¦ï¼‰
            ]);
            
            const pts = curve.getPoints(150);
            // æ‰‹åŠ¨æ·»åŠ æ°´å¹³åº•åº§çº¿ï¼Œç¡®ä¿å®ƒç»å¯¹ç¬”ç›´
            for(let x=-0.8; x<=1.0; x+=0.05) {
                pts.push(new THREE.Vector3(x, -1.8, 0));
            }
            
            applyToTarget(pts, COLORS.gold, 0.6); // å¢åŠ åšåº¦ä½¿å½¢çŠ¶æ›´é¥±æ»¡
        }

        function fillNumberThree() {
            const pts = [];
            const top = new THREE.EllipseCurve(0, 1.1, 1.2, 1.2, -Math.PI/2, Math.PI*1.1, false, 0);
            const bot = new THREE.EllipseCurve(0, -1.1, 1.3, 1.3, -Math.PI*1.1, Math.PI/2, false, 0);
            top.getPoints(80).forEach(p => pts.push(new THREE.Vector3(p.x, p.y, 0)));
            bot.getPoints(80).forEach(p => pts.push(new THREE.Vector3(p.x, p.y, 0)));
            applyToTarget(pts, COLORS.gold, 0.6);
        }

        function fillCake() {
            for(let i=0; i<COUNT; i++) {
                const i3 = i*3;
                const ratio = i/COUNT;
                let x, y, z, col;
                if(ratio < 0.8) {
                    const layer = ratio < 0.4 ? 0 : (ratio < 0.65 ? 1 : 2);
                    const rad = [2.6, 1.8, 1.1][layer];
                    const h_base = [-2.5, -1.0, 0.3][layer];
                    const ang = Math.random()*Math.PI*2;
                    const d = Math.sqrt(Math.random())*rad;
                    x=Math.cos(ang)*d; z=Math.sin(ang)*d; y=h_base + Math.random()*1.3;
                    const mix = (y + 2.5) / 4.5; col = COLORS.pink.clone().lerp(COLORS.white, mix);
                } else {
                    const ang = ratio * 60;
                    const rad = 2.8 - (ratio-0.8)*10;
                    x = Math.cos(ang) * rad; z = Math.sin(ang) * rad; y = -2.5 + (ratio-0.8)*30; col = COLORS.white;
                }
                targetPos[i3]=x; targetPos[i3+1]=y; targetPos[i3+2]=z;
                targetCol[i3]=col.r; targetCol[i3+1]=col.g; targetCol[i3+2]=col.b;
            }
        }

        // --- æ‰‹åŠ¿è¯†åˆ« ---

        let fBuffer = [];
        function setupMediaPipe() {
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8, minTrackingConfidence: 0.8 });
            hands.onResults(onHandResults);
            new Camera(document.getElementById('webcam'), {
                onFrame: async () => { await hands.send({image: document.getElementById('webcam')}); },
                width: 640, height: 480
            }).start();
        }

        function onHandResults(results) {
            const hint = document.getElementById('step-hint');
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const marks = results.multiHandLandmarks[0];
                
                // 1. å®æ—¶æåˆç¼©æ”¾ (æ‹‡æŒ‡ä¸é£ŸæŒ‡)
                const d = Math.hypot(marks[4].x - marks[8].x, marks[4].y - marks[8].y);
                scaleRef = THREE.MathUtils.mapLinear(d, 0.05, 0.4, 0.4, 3.2);
                rotationY = (marks[0].x - 0.5) * 5;

                // 2. ç¨³å®šæ‰‹æŒ‡è®¡æ•°è¯†åˆ«
                let f = 0;
                const isExt = (tip, pip) => Math.hypot(marks[tip].x-marks[0].x, marks[tip].y-marks[0].y) > Math.hypot(marks[pip].x-marks[0].x, marks[pip].y-marks[0].y) * 1.3;
                if(isExt(8,6)) f++; if(isExt(12,10)) f++; if(isExt(16,14)) f++; if(isExt(20,18)) f++;
                if(Math.hypot(marks[4].x-marks[17].x, marks[4].y-marks[17].y) > 0.22) f++;

                fBuffer.push(f); if(fBuffer.length > 10) fBuffer.shift();
                const stableF = fBuffer.reduce((a,b,i,arr)=> (arr.filter(v=>v===a).length >= arr.filter(v=>v===b).length ? a : b), 0);

                if(!isTransitioning) {
                    if (state === 4) {
                        hint.innerText = "ğŸ‚ ç”Ÿæ—¥å¿«ä¹ï¼æ¯”å‡º 1 å¯ä»¥é‡ç½®å“¦";
                        if(stableF === 1) setShape(0);
                    } else {
                        hint.innerText = `âœ¨ é­”æ³•è¯†åˆ«ï¼šè¯·æ¯”å‡º ${state + 1}`;
                        if (stableF === 1 && state === 0) setShape(1);
                        else if (stableF === 2 && state === 1) setShape(2);
                        else if (stableF === 3 && state === 2) setShape(3);
                        else if (stableF === 4 && state === 3) setShape(4);
                    }
                }
            } else {
                hint.innerText = "è¯·å±•ç¤ºæ‰‹æŒå¼€å§‹é­”æ³•";
            }
        }

        // --- åŠ¨ç”» ---
        const activeFws = [];
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();
            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;

            for(let i=0; i<COUNT*3; i++) {
                pos[i] += (targetPos[i] * scaleRef - pos[i]) * 0.08;
                col[i] += (targetCol[i] - col[i]) * 0.05;
            }

            stars.rotation.y += 0.0003;
            if(state === 4) {
                particles.rotation.y += 0.006;
                if(Math.random() < 0.06) launchFw();
                updateFw(dt);
            } else {
                particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, rotationY, 0.1);
                for(let i=0; i<COUNT; i++) pos[i*3+1] += Math.sin(time + i*0.1)*0.002;
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            composer.render();
        }

        function launchFw() {
            const origin = new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*15, -12);
            const c = new THREE.Color().setHSL(Math.random(), 1, 0.6);
            for(let i=0; i<80; i++) {
                activeFws.push({ p: origin.clone(), v: new THREE.Vector3((Math.random()-0.5)*0.35, (Math.random()-0.5)*0.35, (Math.random()-0.5)*0.35), l: 1.0, c: c });
                if(activeFws.length > FW_COUNT) activeFws.shift();
            }
        }

        function updateFw(dt) {
            const fPos = fwGeo.attributes.position.array;
            const fCol = fwGeo.attributes.color.array;
            for(let i=0; i<FW_COUNT; i++) {
                const f = activeFws[i];
                if(f && f.l > 0) {
                    f.p.add(f.v); f.v.y -= 0.005; f.l -= dt * 0.7;
                    fPos[i*3]=f.p.x; fPos[i*3+1]=f.p.y; fPos[i*3+2]=f.p.z;
                    fCol[i*3]=f.c.r*f.l; fCol[i*3+1]=f.c.g*f.l; fCol[i*3+2]=f.c.b*f.l;
                } else fPos[i*3]=999;
            }
            fwGeo.attributes.position.needsUpdate = true;
            fwGeo.attributes.color.needsUpdate = true;
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>